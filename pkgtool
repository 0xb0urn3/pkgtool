#!/usr/bin/env python3

import os
import subprocess
import sys
import shutil
import logging
import json
import time
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Any
from pathlib import Path
from rich.console import Console
from rich.table import Table
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich.panel import Panel
from rich.layout import Layout
from rich.live import Live
from rich.syntax import Syntax
from rich.prompt import Prompt, Confirm

# Initialize Rich console
console = Console()

# Configure logging with rich formatting
logging.basicConfig(
    level=logging.INFO,
    format="%(message)s",
    handlers=[
        logging.FileHandler("pkg_tool.log"),
        logging.StreamHandler()
    ]
)

class PKGTool:
    """Advanced package management tool with modern CLI interface."""
    
    VERSION = "0.1.2-ALPHA"
    AUTHOR = "0xb0urn3"
    
    def __init__(self):
        self.console = Console()
        self.manager = self.detect_pkg_manager()
        self.history_file = Path.home() / '.pkg_tool_history.json'
        self.config_file = Path.home() / '.pkg_tool_config.json'
        self.load_history()
        self.load_config()
        
    def load_config(self) -> None:
        """Load tool configuration from JSON file."""
        default_config = {
            "theme": "cyber",
            "auto_cleanup": True,
            "backup_enabled": True,
            "backup_dir": str(Path.home() / '.pkg_tool_backups'),
            "max_history": 100,
            "sync_enabled": False,
            "sync_url": "",
        }
        
        if self.config_file.exists():
            try:
                with open(self.config_file) as f:
                    self.config = {**default_config, **json.load(f)}
            except json.JSONDecodeError:
                self.config = default_config
        else:
            self.config = default_config
            self.save_config()
    
    def save_config(self) -> None:
        """Save current configuration to file."""
        with open(self.config_file, 'w') as f:
            json.dump(self.config, f, indent=2)

    def load_history(self) -> None:
        """Load package management history with enhanced metadata."""
        if self.history_file.exists():
            try:
                with open(self.history_file) as f:
                    self.history = json.load(f)
            except json.JSONDecodeError:
                self.history = []
        else:
            self.history = []

    def save_history(self, action: str, packages: List[str], success: bool, metadata: Dict[str, Any] = None) -> None:
        """Save package management actions with extended metadata."""
        entry = {
            'timestamp': datetime.now().isoformat(),
            'action': action,
            'packages': packages,
            'package_manager': self.manager,
            'success': success,
            'system_info': self.get_system_info(),
            'metadata': metadata or {}
        }
        self.history.append(entry)
        
        # Maintain history size limit
        if len(self.history) > self.config['max_history']:
            self.history = self.history[-self.config['max_history']:]
        
        with open(self.history_file, 'w') as f:
            json.dump(self.history, f, indent=2)

    @staticmethod
    def get_system_info() -> Dict[str, str]:
        """Gather system information for logging."""
        info = {}
        try:
            with open('/etc/os-release') as f:
                for line in f:
                    if '=' in line:
                        key, value = line.strip().split('=', 1)
                        info[key] = value.strip('"')
        except FileNotFoundError:
            pass
        return info

    @staticmethod
    def detect_pkg_manager() -> Optional[str]:
        """Detect the system's package manager with enhanced detection."""
        managers = {
            "apt": "/usr/bin/apt",
            "pacman": "/usr/bin/pacman",
            "dnf": "/usr/bin/dnf",
            "zypper": "/usr/bin/zypper",
            "xbps-install": "/usr/bin/xbps-install",
            "apk": "/sbin/apk",
            "nix": "/run/current-system/sw/bin/nix",
            "brew": "/usr/local/bin/brew"
        }
        
        for manager, path in managers.items():
            if os.path.exists(path):
                return manager
        return None

    COMMANDS = {
        "apt": {
            "search": "apt search {pkg}",
            "install": "sudo apt install -y {pkg}",
            "remove": "sudo apt remove -y {pkg}",
            "update": "sudo apt update && sudo apt upgrade -y",
            "clean": "sudo apt autoremove -y && sudo apt clean",
            "info": "apt show {pkg}",
            "list": "apt list --installed",
            "hold": "sudo apt-mark hold {pkg}",
            "unhold": "sudo apt-mark unhold {pkg}",
            "depends": "apt-cache depends {pkg}",
            "size": "apt-cache show {pkg} | grep 'Size'",
            "backup": "dpkg --get-selections > {backup_file}",
            "restore": "sudo dpkg --set-selections < {backup_file} && sudo apt-get dselect-upgrade",
            "verify": "debsums {pkg}",
            "orphans": "deborphan",
        },
        # Add similar extended commands for other package managers...
    }

    def execute_command(self, command: str) -> Tuple[bool, str]:
        """Execute a shell command with progress indication."""
        with Progress(
            SpinnerColumn(),
            TextColumn("[bold blue]Executing command..."),
            transient=True
        ) as progress:
            task = progress.add_task("", total=None)
            try:
                result = subprocess.run(
                    command,
                    shell=True,
                    check=True,
                    text=True,
                    capture_output=True
                )
                return True, result.stdout
            except subprocess.CalledProcessError as e:
                return False, e.stderr

    def create_backup(self) -> None:
        """Create a backup of installed packages."""
        if not self.config['backup_enabled']:
            self.console.print("[yellow]Backup feature is disabled in config[/]")
            return

        backup_dir = Path(self.config['backup_dir'])
        backup_dir.mkdir(parents=True, exist_ok=True)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        backup_file = backup_dir / f"pkg_backup_{timestamp}.json"
        
        with Progress() as progress:
            task = progress.add_task("[cyan]Creating backup...", total=100)
            
            # Get list of installed packages
            success, output = self.execute_command(self.COMMANDS[self.manager]["list"])
            if not success:
                self.console.print("[red]Backup failed![/]")
                return
                
            backup_data = {
                'timestamp': timestamp,
                'package_manager': self.manager,
                'system_info': self.get_system_info(),
                'packages': output.splitlines()
            }
            
            progress.update(task, advance=50)
            
            # Save backup
            with open(backup_file, 'w') as f:
                json.dump(backup_data, f, indent=2)
                
            progress.update(task, advance=50)
        
        self.console.print(f"[green]Backup created successfully: {backup_file}[/]")

    def show_dashboard(self) -> None:
        """Display system package management dashboard."""
        layout = Layout()
        layout.split_column(
            Layout(name="header"),
            Layout(name="body"),
            Layout(name="footer")
        )
        
        # Header
        header = Table.grid()
        header.add_row(
            f"[bold cyan]PKG Tool v{self.VERSION}[/] by [bold red]{self.AUTHOR}[/]"
        )
        
        # System info
        system_info = self.get_system_info()
        info_table = Table(show_header=False, box=None)
        for key, value in system_info.items():
            info_table.add_row(f"[dim]{key}:[/]", f"[bold]{value}[/]")
        
        layout["header"].update(Panel(header))
        layout["body"].update(Panel(info_table))
        
        self.console.print(layout)

    def show_menu(self) -> None:
        """Display the interactive menu with rich formatting."""
        self.show_dashboard()
        
        menu_table = Table(show_header=False, box=None)
        menu_items = [
            ("1", "🔍 Search packages"),
            ("2", "📦 Install packages"),
            ("3", "🗑️ Remove packages"),
            ("4", "🔄 Update system"),
            ("5", "🧹 Clean system"),
            ("6", "ℹ️ Package information"),
            ("7", "📋 List installed packages"),
            ("8", "🔒 Hold package version"),
            ("9", "🔓 Unhold package version"),
            ("10", "🔗 Show dependencies"),
            ("11", "📊 Show package size"),
            ("12", "📜 View history"),
            ("13", "💾 Create backup"),
            ("14", "⚙️ Settings"),
            ("15", "❌ Exit")
        ]
        
        for key, label in menu_items:
            menu_table.add_row(
                f"[cyan]{key}[/]",
                f"[bold white]{label}[/]"
            )
        
        self.console.print(Panel(menu_table, title="Main Menu"))

    def run(self) -> None:
        """Enhanced main program loop."""
        if not self.manager:
            self.console.print("[red]Unsupported package manager or distribution.[/]")
            sys.exit(1)

        while True:
            self.show_menu()
            choice = Prompt.ask("Enter your choice", choices=[str(i) for i in range(1, 16)])
            
            if choice == "15":
                self.console.print("[cyan]Goodbye! 👋[/]")
                sys.exit(0)
                
            # Handle menu choices with new features...
            # (Implementation of other menu options would follow here)

if __name__ == "__main__":
    try:
        tool = PKGTool()
        tool.run()
    except KeyboardInterrupt:
        console.print("\n[yellow]Program terminated by user.[/]")
        sys.exit(0)
